##################重点############
1.	参数初始化列表
问题1-1：const 成员变量可以通过什么方式初始化
初始化 const 成员变量的唯一方法就是使用参数初始化表

2.	const关键字
问题2-1：C与C++中const的不同点，以及作用
C语言中的const：
-const修饰的变量是只读的，本质还是变量
-const修饰的局部变量在栈上分配空间
-const修饰的全局变量在只读存储区分配空间
-const只在编译期有用，在运行期无用
const修饰的变量不是真的常量，它只是告诉编译器该变量不能出现在赋值符号的左边，所以说在编译期有用，在运行期无用
C的处理和普通变量一样，会到内存中读取数据；

C++中的const：
-当碰见const声明时在符号表中放入常量
-编译过程中若发现使用常量则直接以符号表中的值替换
-编译过程中若发现下述情况则给对应的常量分配存储空间
	.对const常量使用了extern
	.对const常量使用&操作符
	注意：C++编译器虽然可能为const常量分配空间，但是不会使用其存储空间的值
C++ 对 const 的处理更像是编译时期的 #define ，是一个值替换的过程。

3.	static(静态的)关键字

问题3-1：说说static关键字的作用
静态成员变量：
-静态成员变量属于整个类所有
-静态成员变量的生命期不依赖于任何对象
-可以通过类名、对象名直接访问公有静态成员变量
-所有对象共享类的成员变量
-静态成员变量需要在类外单独分配空间
-静态成员变量在程序内位于全局数据区

静态成员函数：
-静态成员函数属于整个类所有
-可以通过类名、对象名直接访问公有静态成员函数
-静态成员函数由于没有隐藏的this指针，只能直接访问静态成员变量（函数）
      

4.	volatile(易变的)关键字

问题4-1：说说volatile关键字的作用
-volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。
 所以使用 volatile 告诉编译器不应对这样的对象进行优化。
-volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值）
-const 可以是 volatile （如只读的状态寄存器）
-指针可以是 volatile


5.	extern关键字
基本解释：extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。
          此外extern也可用来进行链接指定。

问题5-1：说说extern关键字的作用
在C++中常在头文件见到extern "C"修饰函数，那有什么作用呢？ 是用于C++链接在C语言模块中定义的函数。
C++虽然兼容C，但C++文件中函数编译后生成的符号与C语言生成的不同。因为C++支持函数重载，C++函数编译后生成的符时带有函数参数类型的信息，而C则没有。
例如int add(int a, int b)函数经过C++编译器生成.o文件后，add会变成形如add_int_int之类的, 而C的话则会是形如_add, 就是说：相同的函数，在C和C++中，编译后生成的符号不同。
这就导致一个问题：如果C++中使用C语言实现的函数，在编译链接的时候，会出错，提示找不到对应的符号。此时extern "C"就起作用了：告诉链接器去寻找_add这类的C语言符号，而不是经过C++修饰的符号。

6.	内联函数

问题6-1：说说宏定义与内联函数的区别
内联函数和普通函数相比可以加快程序运行的速度，因为不需要中断调用，省去了函数调用时的压栈，跳转和返回的开销，
在编译的时候内联函数可以直接被镶嵌到目标代码中。内联函数要做参数类型检查，这是内联函数跟宏相比的优势。

7.	struct与class的区别

问题7-1：struct与class的区别
-在用struct定义类时，所有成员的默认的访问级别为public
-在用private定义类时，所有成员的默认的访问级别为private

8.	C++中新的类型转换
static_cast（静态类型转换）：
-用于基本类型间的转换
-不能用于基本类型指针间的转换
-用于有继承关系对象之间的转换和类指针之间的转换

const_cast：
-用于去除变量的只读属性
-强制转换的目标类型必须时指针或引用

dynamic_cast（动态类型转换：多态）：
-用于有继承关系间的转换
-用于有交叉关系的类指针间的转换
-具有类型检查的功能
-需要虚函数的支持

reinterpret_cast：
将一个指针的类型重新解释成另一种指针类型
-用于指针类型间的强制转换
-用于整数和指针类型间的强制转换

9.	引用与指针
-引用必须初始化，不能为空，不能更换目标（引用底层实现是一个const指针）
-指针可以不初始化，可以为空，可以更换目标

10.拷贝构造函数的意义
-浅拷贝
  .拷贝后对象的物理状态相同（对象的成员变量地址相同，意味着成员变量共享一个地址的数据）
-深拷贝
  .拷贝后对象的逻辑状态相同（对象的成员变量地址不同，意味着这时候的拷贝是有复制两份数据）
编译器提供的拷贝构造函数只进行浅拷贝

什么时候需要深拷贝：
-对象中有成员指代了系统中的资源
  .成员指向了动态内存空间
  .成员打开了动态内存空间
  .成员使用了系统中的网络端口
 
 一般而言，自定以的拷贝构造函数实现的都是深拷贝，因为编译器已提供了浅拷贝构造函数
 Test(const Test& t)
 {
     i = t.i;
     j = t.j;
     p = new int;
     *p = *t.p;
 }

参考：第19课 - 对象的构造（下）








